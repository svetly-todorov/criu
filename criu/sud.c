#include "compel/ptrace.h"
#include "sud.h"

#include "protobuf.h"
#include "images/sud.pb-c.h"

static struct rb_root sud_tid_rb_root = RB_ROOT;
static struct seccomp_entry *sud_tid_entry_root;

/* Autogenerated protobuf message structure */
static SudEntry *sud_img_entry;

struct sud_entry *sud_lookup(pid_t tid_real, bool create, bool mandatory)
{
	struct sud_entry *entry = NULL;

	struct rb_node *node = sud_tid_rb_root.rb_node;
	struct rb_node **new = &sud_tid_rb_root.rb_node;
	struct rb_node *parent = NULL;

	while (node) {
		struct sud_entry *this = rb_entry(node, struct sud_entry, node);

		parent = *new;
		if (tid_real < this->tid_real)
			node = node->rb_left, new = &((*new)->rb_left);
		else if (tid_real > this->tid_real)
			node = node->rb_right, new = &((*new)->rb_right);
		else
			return this;
	}

	if (create) {
		entry = xzalloc(sizeof(*entry));
		if (!entry)
			return NULL;
		rb_init_node(&entry->node);
		entry->tid_real = tid_real;

		entry->next = sud_tid_entry_root, sud_tid_entry_root = entry;
		rb_link_and_balance(&sud_tid_rb_root, &entry->node, parent, new);
	} else {
		if (mandatory)
			pr_err("Can't find entry on tid_real %d\n", tid_real);
	}

	return entry;
}

/* This must run *before* parasite code, else the */
int sud_collect_entry(pid_t tid_real)
{
    struct sud_entry *entry;

	entry = sud_lookup(tid_real, true, false);
	if (!entry) {
		pr_err("Can't create entry on tid_real %d\n", tid_real);
		return -1;
	}

    struct ptrace_sud_config config;
    if (ptrace_get_sud(tid_real, &config)) {
        pr_err("Failed to get SUD settings for %d", tid_real);
        return -1;
    }

    entry->mode = config.mode;
    entry->selector = config.selector;
    entry->offset = config.offset;
    entry->len = config.len;

	pr_debug("Collected tid_real %d, SUD mode %#x\n", tid_real, mode);
	return 0;
}

/* Traverse the nodes from collect_entry, and write data to protobuf */
int dump_sud(void)
{
	SudEntry se = SUD_ENTRY__INIT;
	struct sud_entry *entry;
	size_t img_filter_pos = 0, nr_chains = 0;
	struct rb_node *node;
	int ret;

	for (node = rb_first(&seccomp_tid_rb_root); node; node = rb_next(node)) {
		entry = rb_entry(node, struct seccomp_entry, node);
		nr_chains += entry->nr_chains;
	}

	se.n_seccomp_filters = nr_chains;
	if (nr_chains) {
		se.seccomp_filters = xmalloc(sizeof(*se.seccomp_filters) * nr_chains);
		if (!se.seccomp_filters)
			return -1;
	}

	for (node = rb_first(&seccomp_tid_rb_root); node; node = rb_next(node)) {
		entry = rb_entry(node, struct seccomp_entry, node);

		if (!entry->nr_chains)
			continue;

		for (chain = entry->chain; chain; chain = chain->prev) {
			if (img_filter_pos >= nr_chains) {
				pr_err("Unexpected position %zu > %zu\n", img_filter_pos, nr_chains);
				xfree(se.seccomp_filters);
				return -1;
			}

			se.seccomp_filters[img_filter_pos] = &chain->filter;
			if (chain != entry->chain) {
				chain->filter.has_prev = true;
				chain->filter.prev = img_filter_pos - 1;
			}
			img_filter_pos++;
		}

		entry->img_filter_pos = img_filter_pos - 1;
	}

	ret = pb_write_one(img_from_set(glob_imgset, CR_FD_SECCOMP), &se, PB_SECCOMP);

	xfree(se.seccomp_filters);

	for (node = rb_first(&seccomp_tid_rb_root); node; node = rb_next(node)) {
		entry = rb_entry(node, struct seccomp_entry, node);
		seccomp_free_chain(entry);
	}

	return ret;
}